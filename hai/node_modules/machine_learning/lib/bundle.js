(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (process){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var utils = require('./utils');
var math = utils.math;
function DecisionNode(options) {
    var self = this;
    self.col = (typeof options['col'] === 'undefined') ? -1 : options['col'];
    self.value = options['value'];
    self.results = options['results'];
    self.tb = options['tb'];
    self.fb = options['fb'];
}
DecisionNode.prototype.print =  function() {
    var self = this;
    printTree(self,'');
}

DecisionTree = module.exports = function (options) {
    var self = this;
    self.data = options['data'];
    self.result = options['result'];
}

DecisionTree.prototype.build = function(options) {
    var self = this;
    var rows = [];
    var i;
    for(i=0; i<self.data.length; i++) {
        rows.push(self.data[i]);
        rows[i].push(self.result[i]);
    }
    self.tree = buildTree(rows,entropy);
    return self.tree;
};

DecisionTree.prototype.print = function() {

    var self = this;
    printTree(self.tree,'');
}

DecisionTree.prototype.classify = function(observation) {
    var self = this;
    return classify(observation,self.tree);
}

DecisionTree.prototype.prune = function(mingain){
    var self = this;
    prune(self.tree,mingain);
}

DecisionTree.prototype.getTree = function() {
    return this.tree;
}

function prune(tree,mingain) {
    if(typeof tree.tb.results === 'undefined')
        prune(tree.tb,mingain);
    if(typeof tree.fb.results === 'undefined')
        prune(tree.fb,mingain);

    if(typeof tree.tb.results !== 'undefined' && typeof tree.fb.results !== 'undefined') {
        var tb = [], fb = [], tbfb = [];
        Object.keys(tree.tb.results).forEach(function(key) {
            for(var i=0; i<tree.tb.results[key] ; i++) {
                tb.push([key]);
                tbfb.push([key]);
            }
        });
        Object.keys(tree.fb.results).forEach(function(key) {
            for(var i=0; i<tree.fb.results[key] ; i++) {
                fb.push([key]);
                tbfb.push([key]);
            }
        });
        var p = 1.*tb.length / tbfb.length;
        var delta = entropy(tbfb) - p * entropy(tb) - (1-p) * entropy(fb);
        if(delta < mingain) {
            // pruning
            tree.tb = undefined;
            tree.fb = undefined;
            tree.results = uniqueCounts(tbfb);
        }
    }
}

function classify(observaton,tree) {
    if(typeof tree.results !== 'undefined')
        return tree.results;
    else {
        var v = observaton[tree.col];
        var branch;
        if(utils.isNumber(v)) {
            if(v>=tree.value) branch = tree.tb;
            else branch = tree.fb;
        } else {
            if(v === tree.value) branch = tree.tb;
            else branch = tree.fb;
        }
        return classify(observaton,branch);
    }
}

function printTree(tree,indent) {
    indent = indent || '';
    if(typeof tree.results !== 'undefined')
        console.log(tree.results);
    else {
        // print condition
        console.log(tree.col+':'+tree.value+'? ');

        // print branches
        process.stdout.write(indent + 'T->');
        printTree(tree.tb,indent +'  ');
        process.stdout.write(indent + 'F->');
        printTree(tree.fb,indent +'  ');
    }
}

function buildTree(rows,scoref) {
    if(rows.length == 0) return new DecisionNode();
    var currentScore = scoref(rows);
    var bestGain = 0.0, bestCriteria, bestSets;
    var columnCount = rows[0].length - 1;
    var col, i;
    for(col=0; col<columnCount; col++) {
        var columnValues = {};
        for(i=0; i<rows.length; i++) {
            columnValues[rows[i][col]] = 1;
        }
        var values = Object.keys(columnValues);
        for(i=0; i<values.length; i++) {
            var sets = divideSet(rows,col,values[i]);
            var p = 1.*sets[0].length / rows.length;
            var gain = currentScore - p*scoref(sets[0]) - (1-p)*scoref(sets[1]);
            if(gain > bestGain && sets[0].length > 0 && sets[1].length > 0) {
                bestGain = gain;
                bestCriteria = [col,values[i]];
                bestSets = sets;
            }
        }
    }
    if(bestGain > 0) {
        var trueBranch = buildTree(bestSets[0],scoref);
        var falseBranch = buildTree(bestSets[1],scoref);
        return new DecisionNode({
            col : bestCriteria[0],
            value : bestCriteria[1],
            tb : trueBranch,
            fb : falseBranch
        });
    } else {
        return new DecisionNode({
            results : uniqueCounts(rows)
        });
    }
}

function entropy(rows) {
    var log2 = function(x) {return Math.log(x)/Math.log(2);};
    var results = uniqueCounts(rows);
    var ent = 0.0;
    var keys = Object.keys(results);
    var i;
    for(i=0; i<keys.length; i++) {
        var p = 1.*results[keys[i]]/rows.length;
        ent -= 1.*p*log2(p);
    }
    return ent;
}
function uniqueCounts(rows) {
    var results = {};
    var i;
    for(i=0; i<rows.length; i++) {
        var r = rows[i][rows[i].length-1];
        if(typeof results[r] === 'undefined')
            results[r] = 0;
        results[r]++;
    }
    return results;
}
function divideSet(rows,column,value) {
    var splitFunction;

    if(utils.isNumber(value))
        splitFunction = function(row) {return row[column] >= value;};
    else
        splitFunction = function(row) {return row[column] === value;};
    var set1 = [], set2 = [];
    var i;
    for(i=0; i<rows.length; i++) {
        if(splitFunction(rows[i]))
            set1.push(rows[i]);
        else
            set2.push(rows[i]);
    }
    return [set1,set2];
}
}).call(this,require('_process'))
},{"./utils":13,"_process":1}],3:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
var math = require('./utils').math;
HiddenLayer = module.exports = function (settings) {
    var self = this;
    self.input = settings['input'];

    if(typeof settings['W'] === 'undefined') {
        var a = 1. / settings['n_in'];
        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);
    }
    if(typeof settings['b'] === 'undefined')
        settings['b'] = math.zeroVec(settings['n_out']);
    if(typeof settings['activation'] === 'undefined')
        settings['activation'] = math.sigmoid;

    self.W = settings['W'];
    self.b = settings['b'];
    self.activation = settings['activation'];
}

HiddenLayer.prototype.output = function(input) {
    var self = this;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return math.activateMat(linearOutput,self.activation);
};

HiddenLayer.prototype.linearOutput = function(input) { // returns the value before activation.
    var self = this;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return linearOutput;
}

HiddenLayer.prototype.backPropagate = function (input) { // example+num * n_out matrix
    var self = this;
    if(typeof input === 'undefined')
        throw new Error("No BackPropagation Input.")

    var linearOutput = math.mulMat(input, m.transpose(self.W));
    return linearOutput;
}

HiddenLayer.prototype.sampleHgivenV = function(input) {
    var self = this;
    if(typeof input !== 'undefined')
        self.input = input;

    var hMean = self.output();
    var hSample = math.probToBinaryMat(hMean);
    return hSample;
}
},{"./utils":13}],4:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
var math = require('./utils').math;
LogisticRegression = module.exports = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.W = math.zeroMat(settings['n_in'],settings['n_out']);
    self.b = math.zeroVec(settings['n_out']);
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
};

LogisticRegression.prototype.train = function (settings) {
    var self = this;
    var lr = 0.1, epochs = 200;
    if(typeof settings['input'] !== 'undefined')
        self.x = settings['input'];
    if(typeof settings['lr'] !== 'undefined')
        lr = settings['lr'];
    if(typeof settings['epochs'] !== 'undefined')
        epochs = settings['epochs'];
    var i;
    var currentProgress = 1;
    for(i=0;i<epochs;i++) {
        var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
        var deltaY = math.minusMat(self.y,probYgivenX);

        var deltaW = math.mulMat(math.transpose(self.x),deltaY);
        var deltaB = math.meanMatAxis(deltaY,0);

        self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
        self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
        if(self.settings['log level'] > 0) {
            var progress = (1.*i/epochs)*100;
            if(progress > currentProgress) {
                console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
                currentProgress++;
            }
        }
    }
    if(self.settings['log level'] > 0)
        console.log("LogisticRegression Final Cross Entropy : ",self.getReconstructionCrossEntropy());
};

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
    var self = this;
    var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
    var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
    var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
        math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));
    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy;
};

LogisticRegression.prototype.predict = function (x) {
    var self = this;
    return math.softmaxMat(math.addMatVec(math.mulMat(x,self.W),self.b));
};

LogisticRegression.prototype.set = function(property,value) {
    var self = this;
    self.settings[property] = value;
}
},{"./utils":13}],5:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var math = require('./utils').math;
Kmeans = module.exports;

Kmeans.cluster = function(options) {
    var data = options['data'];
    var k = options['k'];
    var distance = getDistanceFunction(options['distance']);
    var epochs = options['epochs'];
    var init_using_data = options['init_using_data'];
    if(typeof init_using_data === "undefined");
        init_using_data = true;
    var means = getRandomMeans(data,k, init_using_data);

    var epoch, i, j, l;
    var clusters = [];
    for(i=0 ; i<k ; i++)
        clusters.push([]);

    for(epoch=0 ; epoch<epochs ; epoch++) {
        clusters = [];
        for(i=0 ; i<k ; i++)
            clusters.push([]);

        // Find which centroid is the closest for each row
        for(i=0 ; i<data.length ; i++) {
            var bestmatch = 0;
            for(j=0 ; j<k ; j++) {
                if(distance(means[j],data[i]) < distance(means[bestmatch],data[i])) bestmatch = j;
            }
            clusters[bestmatch].push(i);
        }

        // Move the centroids to the average of their members
        for(i=0 ; i<k ; i++) {
            var avgs = [];
            for(j=0 ; j<data[0].length ; j++)
                avgs.push(0.0);
            if(clusters[i].length > 0) {
                for(j=0 ; j<clusters[i].length ; j++) {
                    for(l=0 ; l<data[0].length ; l++) {
                        avgs[l] += data[clusters[i][j]][l];
                    }
                }
                for(j=0 ; j<data[0].length ; j++) {
                    avgs[j] /= clusters[i].length;
                }
                means[i] = avgs;
            }
        }
    }
    return {
        clusters : clusters,
        means : means
    };
}

var getRandomMeans = function(data,k, init_using_data) {
    var clusters = [];
    if(init_using_data) {
        var cluster_index = math.range(data.length);
        cluster_index = math.shuffle(cluster_index);
        for(i=0 ; i<k ; i++) {
            clusters.push(data[cluster_index[i]]);
        }
    } else {
        var i,j;
        var ranges = [];
        for(i=0 ; i<data[0].length ; i++) {
            var min = data[0][i] , max = data[0][i];
            for(j=0 ; j<data.length ; j++) {
                if(data[j][i] < min) min = data[j][i];
                if(data[j][i] > max) max = data[j][i];
            }
            ranges.push([min,max]);
        }
        for(i=0 ; i<k ; i++) {
            var cluster = [];
            for(j=0 ; j<data[0].length;j++) {
                cluster.push(Math.random() * (ranges[j][1] - ranges[j][0]) + ranges[j][0]);
            }
            clusters.push(cluster);
        }
    }
    return clusters;
}


function getDistanceFunction(options) {
    if(typeof options === 'undefined') {
        return math.euclidean;
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'euclidean') {
        return math.euclidean;
    } else if (options['type'] === 'pearson') {
        return math.pearson;
    }
}

},{"./utils":13}],6:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var math = require('./utils').math;
KNN = module.exports = function (options) {
    var self = this;
    self.data = options['data'];
    self.result = options['result'];
}

KNN.prototype.predict = function(options) {
    var self = this;
    var x = options['x'];
    var k = options['k'] || 3;
    var weightf = getWeightedFunction(options['weightf']);
    var distance = getDistanceFunction(options['distance']);
    var distanceList = [];
    var i;
    for(i=0; i<self.data.length; i++)
        distanceList.push([distance(x,self.data[i]),i]);
    distanceList.sort(function(a,b) {return a[0]-b[0];});
    var avg = 0.0;
    var totalWeight = 0, weight;
    for(i=0; i<k; i++) {
        var dist = distanceList[i][0];
        var idx = distanceList[i][1];
        weight = weightf(dist);
        avg += weight * self.result[idx];
        totalWeight += weight;
    }

    avg /= totalWeight;
    return avg;
};

function getWeightedFunction(options) {
    if(typeof options === 'undefined') {
        return function(x) {
            var sigma = 10.0;
            return Math.exp(-1.*x*x/(2*sigma*sigma));
        }
    } else if(typeof options === 'function') {
        return options;
    } else if(options['type'] === 'gaussian') {
        return function(x) {
            var sigma = options['sigma'];
            return Math.exp(-1.*x*x/(2*sigma*sigma));
        }
    } else if(options['type'] === 'none') {
        return function(dist) {
            return 1.0;
        }
    }
}

function getDistanceFunction(options) {
    if(typeof options === 'undefined') {
        return math.euclidean;
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'euclidean') {
        return math.euclidean;
    } else if (options['type'] === 'pearson') {
        return math.pearson;
    }
}

},{"./utils":13}],7:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 18..
 */
ml = module.exports;

ml.kmeans = require('./kmeans');

ml.KNN = require('./knn');

ml.SVM = require('./svm');

ml.nmf = require('./nmf');

ml.optimize = require('./optimize');

ml.MLP = require('./mlp');

ml.DecisionTree = require('./DecisionTree');

ml.LogisticRegression = require('./LogisticRegression');
},{"./DecisionTree":2,"./LogisticRegression":4,"./kmeans":5,"./knn":6,"./mlp":9,"./nmf":10,"./optimize":11,"./svm":12}],8:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
m = module.exports;

m.randn = function() {
    // generate random guassian distribution number. (mean : 0, standard deviation : 1)
    var v1, v2, s;

    do {
        v1 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값
        v2 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값
        s = v1 * v1 + v2 * v2;
    } while (s >= 1 || s == 0);

    s = Math.sqrt( (-2 * Math.log(s)) / s );
    return v1 * s;
}

m.shape = function(mat) {
    var row = mat.length;
    var col = mat[0].length;
    return [row,col];
};

m.addVec = function(vec1, vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i<vec1.length;i++)
            result.push(vec1[i]+vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.minusVec = function(vec1,vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i<vec1.length;i++)
            result.push(vec1[i]-vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
};

m.addMatScalar = function(mat,scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i<row ; i++) {
        var rowVec = [];
        for(j=0 ; j<col ; j++) {
            rowVec.push(mat[i][j] + scalar);
        }
        result.push(rowVec);
    }
    return result;
}

m.addMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i<mat.length;i++)
            result.push(m.addVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.minusMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i<mat.length;i++)
            result.push(m.minusVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.addMat = function (mat1, mat2) {
    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i < mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j < mat1[i].length; j++) {
                result[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
};

m.minusMat = function(mat1, mat2) {
    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i < mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j < mat1[i].length; j++) {
                result[i][j] = mat1[i][j] - mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
}

m.transpose = function (mat) {
    var result = new Array(mat[0].length);
    for (var i = 0; i < mat[0].length; i++) {
        result[i] = new Array(mat.length);
        for (var j = 0; j < mat.length; j++) {
            result[i][j] = mat[j][i];
        }
    }
    return result;
};

m.dotVec = function (vec1, vec2) {
    if (vec1.length === vec2.length) {
        var result = 0;
        for (var i = 0; i < vec1.length; i++) {
            result += vec1[i] * vec2[i];
        }
        return result;
    } else {
        throw new Error("Vector mismatch");
    }
};

m.outerVec = function (vec1,vec2) {
    var mat1 = m.transpose([vec1]);
    var mat2 = [vec2];
    return m.mulMat(mat1,mat2);
};

m.mulVecScalar = function(vec,scalar) {
    var i, result = [];
    for(i=0;i<vec.length;i++)
        result.push(vec[i]*scalar);
    return result;
};

m.mulMatScalar = function(mat,scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i<row ; i++) {
        var rowVec = [];
        for(j=0 ; j<col ; j++) {
            rowVec.push(mat[i][j] * scalar);
        }
        result.push(rowVec);
    }
    return result;
};

m.mulMatElementWise = function(mat1, mat2) {
    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = mat1[i][j] * mat2[i][j]
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.mulMat = function (mat1, mat2) {
    if (mat1[0].length === mat2.length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat2[0].length);
        }


        var mat2_T = m.transpose(mat2);
        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = m.dotVec(mat1[i],mat2_T[j]);
            }
        }
        return result;
    } else {
        throw new Error("Array mismatch");
    }
};

m.sumVec = function(vec) {
    var sum = 0;
    var i = vec.length;
    while (i--) {
        sum += vec[i];
    }
    return sum;
};

m.sumMat = function(mat) {
    var sum = 0;
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++)
          sum += mat[i][j];
    }
    return sum;
};

m.sumMatAxis = function(mat,axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i<row; i++)
            result.push(m.sumVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.sumMatAxis(mat_T,1);
    }
};

m.meanVec = function(vec) {
    return 1. * m.sumVec(vec) / vec.length;
};

m.meanMat = function(mat) {
    var row = mat.length;
    var col = mat[0].length;
    return 1. * m.sumMat(mat) / (row * col);
};

m.meanMatAxis = function(mat,axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i<row; i++)
            result.push(m.meanVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.meanMatAxis(mat_T,1);
    }
};

m.squareVec = function(vec) {
    var squareVec = [];
    var i;
    for(i=0;i<vec.length;i++) {
        squareVec.push(vec[i]*vec[i]);
    }
    return squareVec;
};

m.squareMat = function(mat) {
    var squareMat = [];
    var i;
    for(i=0;i<mat.length;i++) {
        squareMat.push(m.squareVec(mat[i]));
    }
    return squareMat;
};

m.minVec = function(vec) {
    var min = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] < min)
            min = vec[i];
    }
    return min;
};

m.maxVec = function(vec) {
    var max = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] > max)
            max = vec[i];
    }
    return max;
}

m.minMat = function(mat) {
    var min = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++) {
            if(mat[i][j] < min)
                min = mat[i][j];
        }
    }
    return min;
};

m.maxMat = function(mat) {
    var max = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++) {
            if(mat[i][j] < max)
                max = mat[i][j];
        }
    }
    return max;
};

m.zeroVec = function(n) {
    var vec = [];
    while(vec.length < n)
        vec.push(0);
    return vec;
};

m.zeroMat = function(row,col) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.zeroVec(col));
    return mat;
};

m.oneVec = function(n) {
    var vec = [];
    while(vec.length < n)
        vec.push(1);
    return vec;
};

m.oneMat = function(row,col) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.oneVec(col));
    return mat;
};

m.randVec = function(n,lower,upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var vec = [];
    while(vec.length < n)
        vec.push(lower + (upper-lower) * Math.random());
    return vec;
};

m.randMat = function(row,col,lower,upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var mat = [];
    while(mat.length < row)
        mat.push(m.randVec(col,lower,upper));
    return mat;
};

m.randnVec = function(n,mean,sigma) {
    var vec = [];
    while(vec.length < n)
        vec.push(mean+sigma* m.randn());
    return vec;
};

m.randnMat = function(row,col,mean,sigma) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.randnVec(col,mean,sigma));
    return mat;
};

m.identity = function (n) {
    var result = new Array(n);

    for (var i = 0; i < n ; i++) {
        result[i] = new Array(n);
        for (var j = 0; j < n; j++) {
            result[i][j] = (i === j) ? 1 : 0;
        }
    }

    return result;
};

m.sigmoid = function(x) {
    var sigmoid = (1. / (1 + Math.exp(-x)))
    if(sigmoid ==1) {
     //   console.warn("Something Wrong!! Sigmoid Function returns 1. Probably javascript float precision problem?\nSlightly Controlled value to 1 - 1e-14")
        sigmoid = 0.99999999999999; // Javascript Float Precision Problem.. This is a limit of javascript.
    } else if(sigmoid ==0) {
      //  console.warn("Something Wrong!! Sigmoid Function returns 0. Probably javascript float precision problem?\nSlightly Controlled value to 1e-14")
        sigmoid = 1e-14;
    }
    return sigmoid; // sigmoid cannot be 0 or 1;;
};

m.dSigmoid = function(x){
    a = m.sigmoid(x);
    return a * (1. - a);
};

m.probToBinaryMat = function(mat) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i,j;
    var result = [];

    for(i=0;i<row;i++) {
        var rowVec = [];
        for(j=0;j<col;j++) {
            if(Math.random() < mat[i][j])
                rowVec.push(1);
            else
                rowVec.push(0);
        }
        result.push(rowVec);
    }
    return result;
};

m.activateVec = function(vec,activation) {
    var i, result = [];
    for(i=0;i<vec.length;i++)
        result.push(activation(vec[i]));
    return result;
};

m.activateMat = function(mat,activation) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i, j,result = [];
    for(i=0;i<row;i++) {
        var rowVec = [];
        for(j=0;j<col;j++)
            rowVec.push(activation(mat[i][j]));
        result.push(rowVec);
    }
    return result;
};

m.activateTwoVec = function(vec1, vec2,activation) {
    if (vec1.length === vec2.length) {
        var result = new Array(vec1.length);
        for (var i = 0; i < result.length; i++) {
            result[i] = activation(vec1[i],vec2[i]);
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.activateTwoMat = function(mat1, mat2,activation) {
    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = activation(mat1[i][j],mat2[i][j]);
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.fillVec = function(n,value) {
    var vec = [];
    while(vec.length < n)
        vec.push(value);
    return vec;
};

m.fillMat = function(row,col,value) {
    var mat = [];
    while(mat.length < row) {
        var rowVec = [];
        while(rowVec.length < col)
            rowVec.push(value);
        mat.push(rowVec);
    }
    return mat;
};

m.softmaxVec = function(vec) {
    var max = m.maxVec(vec);
    var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})
    return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
};

m.softmaxMat = function(mat) {
    var result=[], i;
    for(i=0 ; i<mat.length ; i++)
        result.push(m.softmaxVec(mat[i]));
    return result;
};

m.randInt = function(min,max) {
  var rand = Math.random() * (max - min + 0.9999) + min
  return Math.floor(rand);
}

m.normalizeVec = function(vec) {
    var i;
    var newVec = [],tot = 0;
    for(i=0; i<vec.length; i++)
        tot += vec[i];
    for(i=0; i<vec.length;i++)
        newVec.push(1.*vec[i]/tot);
    return newVec;
};

m.euclidean = function(x1,x2) {
    var i;
    var distance = 0;
    for(i=0 ; i<x1.length; i++) {
        var dx = x1[i] - x2[i];
        distance += dx * dx;
    }
    return Math.sqrt(distance);
};

m.pearson = function(x, y)
{
    var xy = [];
    var x2 = [];
    var y2 = [];

    for(var i=0; i<x.length; i++)
    {
        xy.push(x[i] * y[i]);
        x2.push(x[i] * x[i]);
        y2.push(y[i] * y[i]);
    }

    var sum_x = 0;
    var sum_y = 0;
    var sum_xy = 0;
    var sum_x2 = 0;
    var sum_y2 = 0;

    for(var i=0; i<x.length; i++)
    {
        sum_x += x[i];
        sum_y += y[i];
        sum_xy += xy[i];
        sum_x2 += x2[i];
        sum_y2 += y2[i];
    }

    var step1 = (x.length * sum_xy) - (sum_x * sum_y);
    var step2 = (x.length * sum_x2) - (sum_x * sum_x);
    var step3 = (x.length * sum_y2) - (sum_y * sum_y);
    var step4 = Math.sqrt(step2 * step3);
    var answer = step1 / step4;

    return answer;
};

m.getNormVec = function(vec) {
    var i;
    var sqsum = 0;
    for(i=0; i<vec.length; i++)
        sqsum += vec[i] * vec[i];
    return Math.sqrt(sqsum);
}

m.gaussian = function(x, sigma) {
    sigma = sigma || 10.0;
    return Math.exp(-1.*x*x/(2*sigma*sigma));
}

m.meanVecs = function(vecs) {
    var sum = m.zeroVec(vecs[0].length);
    var i;
    for(i=0; i<vecs.length; i++)
        sum = m.addVec(sum,vecs[i]);
    return m.activateVec(sum,function(x) {return 1.*x/vecs.length;});
};

m.covarianceVecs = function(vecs) {
    var mat = m.zeroMat(vecs[0].length,vecs[0].length);
    var meanVec = m.meanVecs(vecs);
    var i;
    for(i=0; i<vecs.length; i++) {
        var a = m.minusVec(vecs[i],meanVec);
        mat = m.addMat(mat, m.mulMat(m.transpose([a]),[a]));
    }
    return m.activateMat(mat,function(x) { return 1.*x/(vecs.length-1);});
};

m.shuffle = function(arr){
    var o = [];
    for(var i=0;i<arr.length;i++)
        o.push(arr[i]); // deep copy
    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
};

m.range = function(start, end, step) {
    var ret = [];
    if(typeof step === "undefined")
        step = 1;
    if(typeof end === "undefined") {
        end = start;
        start = 0;
    }
    for(var i=start;i<end;i+=step)
        ret.push(i);
    return ret;
};
// For CRBM
/*
m.phi = function(mat,vec,low,high) {
    var i;
    var result = [];
    for(i=0;i<mat.length;i++) {
        result.push(m.activateTwoVec(mat[i],vec,function(x,y){return low+(high-low)* m.sigmoid(x*y);}))
    }
    return result;
}
*/
},{}],9:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 14..
 */
var math = require('./utils').math;
HiddenLayer = require('./HiddenLayer');
MLP = module.exports = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.sigmoidLayers = [];
    self.nLayers = settings['hidden_layer_sizes'].length;
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
    var i;
    for(i=0 ; i<self.nLayers+1 ; i++) {
        var inputSize, layerInput;
        if(i == 0)
            inputSize = settings['n_ins'];
        else
            inputSize = settings['hidden_layer_sizes'][i-1];

        if(i == 0)
            layerInput = self.x;
        else
            layerInput = self.sigmoidLayers[self.sigmoidLayers.length-1].sampleHgivenV();

        var sigmoidLayer;
        if(i == self.nLayers) {
            sigmoidLayer = new HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings['n_outs'],
                'activation' : math.sigmoid,
                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],
                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]
            });
        } else {
            sigmoidLayer = new HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings['hidden_layer_sizes'][i],
                'activation' : math.sigmoid,
                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],
                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]
            });
        }
        self.sigmoidLayers.push(sigmoidLayer);
    }
};

MLP.prototype.train = function(settings) {
    var self = this;
    var lr = 0.6, epochs = 1000;
    if(typeof settings['lr'] !== 'undefined')
        lr = settings['lr'];
    if(typeof settings['epochs'] !== 'undefined')
        epochs = settings['epochs'];


    var epoch;
    var currentProgress = 1;
    for(epoch=0 ; epoch < epochs ; epoch++) {

        // Feed Forward
        var i;
        var layerInput = [];
        layerInput.push(self.x);
        for(i=0; i<self.nLayers+1 ; i++) {
            layerInput.push(self.sigmoidLayers[i].output(layerInput[i]));
        }
        var output = layerInput[self.nLayers+1];
        // Back Propagation
        var delta = new Array(self.nLayers + 1);
        delta[self.nLayers] = m.mulMatElementWise(m.minusMat(self.y, output),
            m.activateMat(self.sigmoidLayers[self.nLayers].linearOutput(layerInput[self.nLayers]), m.dSigmoid));

        /*
         self.nLayers = 3 (3 hidden layers)
         delta[3] : ouput layer
         delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer
         */
        for(i = self.nLayers - 1; i>=0 ; i--) {
            delta[i] = m.mulMatElementWise(self.sigmoidLayers[i+1].backPropagate(delta[i+1]),
                m.activateMat(self.sigmoidLayers[i].linearOutput(layerInput[i]), m.dSigmoid));
        }
        // Update Weight, Bias
        for(var i=0; i<self.nLayers+1 ; i++) {
            var deltaW = m.activateMat(m.mulMat(m.transpose(layerInput[i]),delta[i]),function(x){return 1. * x / self.x.length;})
            var deltaB = m.meanMatAxis(delta[i],0);
            self.sigmoidLayers[i].W = m.addMat(self.sigmoidLayers[i].W,deltaW);
            self.sigmoidLayers[i].b = m.addVec(self.sigmoidLayers[i].b,deltaB);
        }

        if(self.settings['log level'] > 0) {
            var progress = (1.*epoch/epochs)*100;
            if(progress > currentProgress) {
                console.log("MLP",progress.toFixed(0),"% Completed.");
                currentProgress+=8;
            }
        }
    }
    if(self.settings['log level'] > 0)
        console.log("MLP Final Cross Entropy : ",self.getReconstructionCrossEntropy());
};

MLP.prototype.getReconstructionCrossEntropy = function() {
    var self = this;
    var reconstructedOutput = self.predict(self.x);
    var a = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return x*Math.log(y);
    });

    var b = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return (1-x)*Math.log(1-y);
    });

    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy
}

MLP.prototype.predict = function(x) {
    var self = this;
    var output = x;
    for(i=0; i<self.nLayers+1 ; i++) {
        output = self.sigmoidLayers[i].output(output);
    }
    return output;
};

MLP.prototype.set = function(property,value) {
    var self = this;
    self.settings[property] = value;
}
},{"./HiddenLayer":3,"./utils":13}],10:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var utils = require('./utils');
var math = utils.math;
nmf = module.exports;

nmf.factorize = function(options) {
    var fc = options['features'];
    var matrix = options['matrix'];
    var epochs = options['epochs'];
    var row = math.shape(matrix)[0], col = math.shape(matrix)[1];
    var a = math.randMat(row,fc,0,1);
    var b = math.randMat(fc,col,0,1);

    var i;
    for(i=0 ; i<epochs; i++) {
        var ab = math.mulMat(a,b)
      //  cost = difcost(ab,matrix);
      //  if(i % 10 ==0) console.log("cost ",cost);
      //  if(cost == 0) break;
        var bn = math.mulMat(math.transpose(a),matrix);
        var bd = math.mulMat(math.mulMat(math.transpose(a),a),b);

        b = math.activateTwoMat(math.mulMatElementWise(b,bn),bd,function(x,y){return x/y});

        var an = math.mulMat(matrix, math.transpose(b));
        var ad = math.mulMat(math.mulMat(a,b), math.transpose(b));

        a = math.activateTwoMat(math.mulMatElementWise(a,an),ad,function(x,y){return x/y});
    }
    return [a,b];
}

function difcost(mat1,mat2) {
    var row = math.shape(mat1)[0], col = math.shape(mat1)[1];
    var i , j, difcost=0;
    for(i=0;i<row;i++)
        for(j=0;j<col;j++)
            difcost += Math.pow(mat1[i][j] - mat2[i][j],2);
    return difcost;
}
},{"./utils":13}],11:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var math = require('./utils').math;
optimize = module.exports;

optimize.hillclimb = function(options){
    var domain = options['domain'];
    var costf = options['costf'];

    var i;
    var vec = [];
    for(i=0 ; i<domain.length ; i++)
        vec.push(math.randInt(domain[i][0],domain[i][1]));

    var current, best;

    while(true) {
        var neighbors = [];
        var i,j;

        for(i=0 ; i<domain.length ; i++) {
            if(vec[i] > domain[i][0]) {
                var newVec = [];
                for(j=0 ; j<domain.length ; j++)
                    newVec.push(vec[j]);
                newVec[i]-=1;
                neighbors.push(newVec);
            } else if (vec[i] < domain[i][1]) {
                var newVec = [];
                for(j=0 ; j<domain.length ; j++)
                    newVec.push(vec[j]);
                newVec[i]+=1;
                neighbors.push(newVec);
            }
        }

        current = costf(vec);
        best = current;
        for(i=0 ; i<neighbors.length ; i++) {
            var cost = costf(neighbors[i]);
            if(cost < best) {
                best = cost;
                vec = neighbors[i];
            }
        }
        if(best === current)
            break;
    }
    return vec;
}

optimize.anneal = function(options){
    var domain = options['domain'];
    var costf = options['costf'];
    var temperature = options['temperature'];
    var cool = options['cool'];
    var step = options['step'];
    var callback

    var i;
    var vec = [];
    for(i=0 ; i<domain.length ; i++)
        vec.push(math.randInt(domain[i][0],domain[i][1]));

    while(temperature > 0.1) {
        var idx = math.randInt(0,domain.length - 1);
        var dir = math.randInt(-step,step);
        var newVec = [];
        for(i=0; i<vec.length ; i++)
            newVec.push(vec[i]);
        newVec[idx]+=dir;
        if(newVec[idx] < domain[idx][0]) newVec[idx] = domain[idx][0];
        if(newVec[idx] > domain[idx][1]) newVec[idx] = domain[idx][1];

        var ea = costf(vec);
        var eb = costf(newVec);
        var p = Math.exp(-1.*(eb-ea)/temperature);
        if(eb < ea || Math.random() < p)
            vec = newVec;

        temperature *= cool;
    }

    return vec;
}

optimize.genetic = function(options){
    var domain = options['domain'];
    var costf = options['costf'];
    var population = options['population'];
    var q = options['q'] || 0.3;
    var elite = options['elite'] || population * 0.04;
    var epochs = options['epochs'] || 100;

    var i,j;
    // Initialize population array
    var pop =[];
    for(i=0; i<population; i++) {
        var vec = [];
        for(j=0; j<domain.length; j++)
            vec.push(math.randInt(domain[j][0],domain[j][1]));
        pop.push(vec);
    }
    pop.sort(function(a,b){return costf(a) - costf(b);});

    for(i=0 ; i<epochs ; i++) {
        // elitism
        var newPop = [];
        for(j=0;j<elite;j++)
            newPop.push(pop[j]);

        // compute fitnesses
        var fitnesses = [];
        for(j=0; j<pop.length; j++)
            fitnesses[j] = q * Math.pow(1-q,j);
        fitnesses = math.normalizeVec(fitnesses);

        // crossover, mutate
        for(j=0; j<pop.length - elite;j++) {
            var idx1 = rouletteWheel(fitnesses);
            var idx2 = rouletteWheel(fitnesses);
            var crossovered = crossover(pop[idx1],pop[idx2]);
            var mutated = mutate(crossovered);
            newPop.push(mutated);
        }

        // replacement
        pop = newPop;
        pop.sort(function(a,b){return costf(a) - costf(b);});
       //console.log("Current Cost : ",costf(pop[0]));
    }
    return pop[0];

    function mutate(vec) {
        var idx = math.randInt(0,domain.length - 1);
        var newVec = [];
        var i;
        for(i=0; i<domain.length ; i++)
            newVec.push(vec[i]);
        newVec[idx] += (Math.random() < 0.5) ? 1 : -1;
        if(newVec[idx] < domain[idx][0]) newVec[idx] = domain[idx][0];
        if(newVec[idx] > domain[idx][1]) newVec[idx] = domain[idx][1];
        return newVec;
    }
    function crossover(vec1,vec2) {
        var idx = math.randInt(0,domain.length - 2);
        var newVec = [];
        var i;
        for(i=0; i<idx ; i++)
            newVec.push(vec1[i]);
        for(i=idx; i<domain.length; i++)
            newVec.push(vec2[i]);
        return newVec;
    }
    function rouletteWheel(vec) {
        var a = [0.0];
        var i;
        for(i=0;i<vec.length;i++) {
            a.push(a[i] + vec[i]);
        }
        var rand = Math.random();
        for(i=0;i< a.length;i++) {
            if(rand > a[i] && rand <= a[i+1])
                return i;
        }
        return -1;
    }
};
},{"./utils":13}],12:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 16..
 */

/* References : http://cs229.stanford.edu/materials/smo.pdf . simplified smo algorithm */
var math = require('./utils').math;

SVM = module.exports = function (options) {
    var self = this;
    self.x = options['x'];
    self.y = options['y'];
};

SVM.prototype.train = function (options) {
    var self = this;
    var C = options['C'] || 1.0;
    var tol = options['tol'] || 1e-4;
    var maxPasses = options['max_passes'] || 20;
    var alphatol = options['alpha_tol'] || 1e-5;

    self.kernel = getKernel(options['kernel']);
    self.alphas = math.zeroVec(self.x.length);
    self.b = 0;
    var passes = 0, i;
    var count=0;
    while(passes < maxPasses) {
        var numChangedAlphas = 0;

        for(i=0; i<self.x.length; i++) {

            var E_i = self.f(self.x[i]) - self.y[i];

            if((self.y[i] * E_i < -tol && self.alphas[i] < C) || (self.y[i] * E_i > tol && self.alphas[i] >0)) {

                // Randomly selects j (i != j)
                var j = math.randInt(0,self.x.length-1);
                if(i==j) j = (j+1) % self.x.length;

                var E_j = self.f(self.x[j]) - self.y[j];
                var alpha_i_old = self.alphas[i], alpha_j_old = self.alphas[j];

                // Compute L,H
                var L,H;
                if(self.y[i] !== self.y[j]) {
                    L = Math.max(0, self.alphas[j] - self.alphas[i]);
                    H = Math.min(C, C + self.alphas[j] - self.alphas[i]);
                } else {
                    L = Math.max(0, self.alphas[j] + self.alphas[i] - C);
                    H = Math.min(C, self.alphas[j] + self.alphas[i]);
                }

                if(L === H)
                    continue;

                // Compute ETA
                var ETA = 2 * self.kernel(self.x[i],self.x[j]) - self.kernel(self.x[i],self.x[i]) - self.kernel(self.x[j],self.x[j]);
                if(ETA >= 0)
                    continue;

                // Clip new value to alpha_j
                self.alphas[j] -= 1.*self.y[j] * (E_i - E_j) / ETA;
                if(self.alphas[j] > H)
                    self.alphas[j] = H;
                else if(self.alphas[j] < L)
                    self.alphas[j] = L;

                if(Math.abs(self.alphas[j] - alpha_j_old) < alphatol)
                    continue;

                // Clip new value to alpha_i
                self.alphas[i] += self.y[i] * self.y[j] * (alpha_j_old - self.alphas[j]);

                // update b
                var b1 = self.b - E_i - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[i])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[i],self.x[j]);
                var b2 = self.b - E_j - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[j])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[j],self.x[j]);

                if(0 < self.alphas[i] && self.alphas[i] < C)
                    self.b = b1;
                else if(0 < self.alphas[j] && self.alphas[j] < C)
                    self.b = b2;
                else
                    self.b = (b1+b2)/2.0;

                numChangedAlphas ++ ;
            } // end-if
        } // end-for
        if(numChangedAlphas == 0)
            passes++;
        else
            passes = 0;
    }
}

SVM.prototype.predict = function(x) {
    var self = this;
    if(self.f(x) >= 0)
        return 1;
    else
        return -1;
}

SVM.prototype.f = function(x) {
    var self = this;
    var f = 0, j;
    for(j=0; j<self.x.length; j++)
        f += self.alphas[j] * self.y[j] * self.kernel(self.x[j],x);
    f += self.b;
    return f;
}

function getKernel (options) {
    if(typeof options === 'undefined') {
        return function(x,y) {
            var sigma = 1.0;
            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
        }
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'gaussian') {
        return function(x,y) {
            var sigma = options['sigma'];
            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
        }
    } else if (options['type'] === 'linear') {
        return function(x,y) {
            return math.dotVec(x,y);
        }
    } else if (options['type'] === 'polynomial') {
        return function(x,y) {
            var c = options['c'];
            var d = options['d'];
            return Math.pow(math.dotVec(x,y) + c, d);
        }
    }
}
},{"./utils":13}],13:[function(require,module,exports){
/**
 * Created by joonkukang on 2014. 1. 18..
 */
utils = module.exports;

utils.math = require('./math');

utils.isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
},{"./math":8}]},{},[7]);
